name: Sync Jira Tickets as Labels

on:
  schedule:
    - cron: "*/5 * * * *"  # Every 5 minutes
  workflow_dispatch:

permissions:
  issues: write

jobs:
  sync-labels:
    runs-on: ubuntu-latest

    steps:
      - name: Fetch Active Jira Tickets
        id: fetch-jira
        run: |
          set +e  # Don't exit immediately on error so we can handle it gracefully

          echo "üîç Fetching Jira tickets..."
          RESPONSE_FILE="response.json"
          ERROR_FILE="error.log"
          TICKETS_FILE="jira_tickets.txt"

          HTTP_STATUS=$(curl -s -o "$RESPONSE_FILE" -w "%{http_code}" \
            -u "${{ secrets.JIRA_EMAIL }}:${{ secrets.JIRA_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -X POST \
            --data '{"jql": "project = SCRUM AND status != Done AND status != Closed", "fields": ["key", "summary"], "maxResults": 100}' \
            "${{ secrets.JIRA_BASE_URL }}/rest/api/3/search/jql")

          echo "‚û°Ô∏è HTTP Status: $HTTP_STATUS"

          # Validate HTTP status
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "‚ùå Jira API request failed with status: $HTTP_STATUS" | tee "$ERROR_FILE"
            echo "Response:"
            cat "$RESPONSE_FILE"
            exit 1
          fi

          # Validate JSON
          if ! jq -e . "$RESPONSE_FILE" >/dev/null 2>&1; then
            echo "‚ùå Invalid JSON response from Jira" | tee "$ERROR_FILE"
            cat "$RESPONSE_FILE"
            exit 1
          fi

          # Extract tickets safely
          jq -r '.data.issues[]? | "\(.key)|\(.fields.summary)"' "$RESPONSE_FILE" > "$TICKETS_FILE"
          EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ] || [ ! -s "$TICKETS_FILE" ]; then
            echo "‚ö†Ô∏è No tickets found or jq parsing failed" | tee "$ERROR_FILE"
            cat "$RESPONSE_FILE"
            exit 1
          fi

          echo "‚úÖ Tickets fetched successfully:"
          cat "$TICKETS_FILE"

      - name: Create/Update GitHub Labels
        if: success()  # Run only if previous step succeeded
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const tickets = fs.readFileSync('jira_tickets.txt', 'utf8')
              .split('\n')
              .filter(line => line.trim())
              .map(line => {
                const [key, summary] = line.split('|');
                return { key, summary };
              });

            console.log(`Found ${tickets.length} active Jira tickets`);

            const { data: existingLabels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const existingLabelNames = new Set(existingLabels.map(l => l.name));

            for (const ticket of tickets) {
              if (!existingLabelNames.has(ticket.key)) {
                try {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: ticket.key,
                    color: '0052CC', // Jira blue
                    description: ticket.summary ? ticket.summary.substring(0, 100) : 'No summary available'
                  });
                  console.log(`‚úÖ Created label: ${ticket.key}`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è Could not create label ${ticket.key}: ${error.message}`);
                }
              }
            }

      - name: Upload Debug Artifacts
        if: failure()  # Upload logs if anything fails
        uses: actions/upload-artifact@v4
        with:
          name: jira-debug-logs
          path: |
            response.json
            error.log
